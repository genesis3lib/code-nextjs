name: Code-200-Client
on:
  push:
  workflow_dispatch:

permissions:
  contents: write
  checks: write
  id-token: write

env:
  TF_VERSION: "1.12.2"
  AWS_REGION: {{region}}

jobs:
  client-operations:
    runs-on: ubuntu-latest
    steps:
      - name: Version of AWS CLI
        run: |
          echo "AWS CLI version:"
          which aws
          aws --version

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Env setup
        run: |

          # Set environment variables
          echo "BRANCH={{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" >> $GITHUB_ENV
          if [[ "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "main" || "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "production" || "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "prod" ]]; then
            echo "ENVIRONMENT=prod" >> $GITHUB_ENV
          else
            BRANCH_ENV=$(echo "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" | sed "s/\\//-/g")
            echo "ENVIRONMENT=$BRANCH_ENV" >> $GITHUB_ENV
          fi

          echo "‚úÖ Environment setup completed: {{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}"

      - name: Credential for AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:role/{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}-ops-deploy-s3-role
          aws-region: {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}

      - name: Setup Environment Info
        run: |
          echo "Event name: {{{githubVarsOpen}}} github.event_name  {{{githubVarsClose}}}"
          echo "Branch: {{{githubVarsOpen}}} env.BRANCH  {{{githubVarsClose}}}"
          echo "Environment: {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: {{{githubVarsOpen}}} env.TF_VERSION  {{{githubVarsClose}}}
          terraform_wrapper: false

      - name: Get Terraform Outputs
        run: |
          cd {{opsModule.moduleId}}/terraform
          echo "üîç Getting Terraform outputs for {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}} environment..."

          # Get AWS account ID for state bucket name
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          STATE_BUCKET="{{projectName}}-tfstate-${AWS_ACCOUNT_ID}"
          echo "Using state bucket: ${STATE_BUCKET}"

          # Initialize Terraform to access state
          terraform init -backend-config=backend-${ENVIRONMENT}.hcl -backend-config="bucket=${STATE_BUCKET}" -input=false

{{#isStaticMode}}
          # Get the S3 bucket and CloudFront distribution from Terraform outputs
          S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
          CF_DISTRIBUTION=$(terraform output -raw cloudfront_distribution_id 2>/dev/null || echo "")

          if [ -z "$S3_BUCKET" ]; then
            echo "‚ùå Could not get S3 bucket from Terraform outputs"
            echo "üîç Available Terraform outputs:"
            terraform output
            echo "‚ö†Ô∏è Infrastructure may not be deployed yet - run deploy_apply first"
            exit 1
          fi

          if [ -z "$CF_DISTRIBUTION" ]; then
            echo "‚ùå Could not get CloudFront distribution from Terraform outputs"
            echo "üîç Available Terraform outputs:"
            terraform output
            echo "‚ö†Ô∏è Infrastructure may not be deployed yet - run deploy_apply first"
            exit 1
          fi

          echo "‚úÖ Found S3 bucket: $S3_BUCKET"
          echo "‚úÖ Found CloudFront distribution: $CF_DISTRIBUTION"
          echo "AWS_S3_TARGET=$S3_BUCKET" >> $GITHUB_ENV
          echo "CLOUDFRONT_TARGET=$CF_DISTRIBUTION" >> $GITHUB_ENV

          echo "Target S3: $S3_BUCKET"
          echo "Target CloudFront: $CF_DISTRIBUTION"
{{/isStaticMode}}
{{#isSsrMode}}
          # Get deployment bucket and EC2 info from Terraform outputs
          DEPLOYMENT_BUCKET=$(terraform output -raw deployment_bucket_name 2>/dev/null || echo "")

          if [ -z "$DEPLOYMENT_BUCKET" ]; then
            echo "‚ùå Could not get deployment bucket from Terraform outputs"
            echo "üîç Available Terraform outputs:"
            terraform output
            echo "‚ö†Ô∏è Infrastructure may not be deployed yet - run deploy_apply first"
            exit 1
          fi

          echo "‚úÖ Found deployment bucket: $DEPLOYMENT_BUCKET"
          echo "DEPLOYMENT_BUCKET=$DEPLOYMENT_BUCKET" >> $GITHUB_ENV
{{/isSsrMode}}
        env:
          AWS_DEFAULT_REGION: {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Add build info
        run: |
          echo "export const version = {" > {{frontendModule.moduleId}}/src/utils/version.ts
          echo "  build: '{{{githubVarsOpen}}} github.run_number {{{githubVarsClose}}}'," >> {{frontendModule.moduleId}}/src/utils/version.ts
          echo "  attempt: '{{{githubVarsOpen}}} github.run_attempt {{{githubVarsClose}}}'," >> {{frontendModule.moduleId}}/src/utils/version.ts
          echo "  action: '{{{githubVarsOpen}}} github.action {{{githubVarsClose}}}'," >> {{frontendModule.moduleId}}/src/utils/version.ts
          echo "  modifiedDate: '{{{githubVarsOpen}}} github.event.repository.updated_at {{{githubVarsClose}}}'," >> {{frontendModule.moduleId}}/src/utils/version.ts
          echo "  sha: '$(cd {{frontendModule.moduleId}} && git rev-parse --short HEAD)'" >> {{frontendModule.moduleId}}/src/utils/version.ts
          echo "};" >> {{frontendModule.moduleId}}/src/utils/version.ts

      - name: Setup environment variables
        run: |
          cd {{frontendModule.moduleId}}
          echo "üìù Checking environment file for {{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}} environment..."

          # Next.js uses .env.local for local development
          # For deployments, we use .env.{environment}
          ENV_FILE=".env.{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}"
          if [ -f "$ENV_FILE" ]; then
            echo "‚úÖ Found $ENV_FILE - will use for build"
            # Copy to .env.local for Next.js to pick up
            cp "$ENV_FILE" .env.local
          else
            echo "‚ö†Ô∏è Warning: $ENV_FILE not found, build will use .env.local only"
          fi

          # List env files for debugging
          ls -la .env* || true

      - name: Build
        run: |
          cd {{frontendModule.moduleId}}
          ls -lart
          pwd
          node -v
          npm -v
          npm install
          echo "üî® Running build for {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}} environment..."
          npm run build

      - name: Check and commit package-lock.json changes
        run: |
          cd {{frontendModule.moduleId}}

          # Check if package-lock.json exists and has changes
          if [ -f "package-lock.json" ]; then
            # Check if there are any changes to package-lock.json
            if git diff --quiet package-lock.json && git diff --cached --quiet package-lock.json; then
              echo "‚úÖ No changes to package-lock.json"
            else
              echo "üîÑ package-lock.json was modified during build, committing changes..."

              # Configure git for the action
              git config --local user.email "action@github.com"
              git config --local user.name "GitHub Action"

              # Add and commit the package-lock.json
              git add package-lock.json
              git commit -m "ü§ñ updated package-lock.json from build process"

              # Push the commit back to the repository
              git push
              echo "‚úÖ package-lock.json committed and pushed successfully"
            fi
          else
            echo "‚ÑπÔ∏è No package-lock.json found after build"
          fi

{{#isStaticMode}}
      - name: Deploy - Sync S3 Bucket
        run: |
          echo "Deploying to ${AWS_S3_TARGET} [${CLOUDFRONT_TARGET}]"
          aws s3 sync {{frontendModule.moduleId}}/out "s3://${AWS_S3_TARGET}" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} --delete

      - name: Deploy - Invalidate CloudFront cache
        run: |
          echo "Invalidating CloudFront distribution cache for ${CLOUDFRONT_TARGET}"
          aws cloudfront create-invalidation --distribution-id "${CLOUDFRONT_TARGET}" --paths "/*"
{{/isStaticMode}}
{{#isSsrMode}}
      - name: Package application for SSR deployment
        run: |
          cd {{frontendModule.moduleId}}
          echo "üì¶ Packaging Next.js SSR application..."

          # Create deployment package with standalone output
          tar -czf ../nextjs-app.tar.gz \
            .next/standalone \
            .next/static \
            public \
            package.json \
            package-lock.json

          echo "‚úÖ Package created: nextjs-app.tar.gz"
          ls -lh ../nextjs-app.tar.gz

      - name: Upload to S3
        run: |
          echo "üì§ Uploading package to S3..."
          aws s3 cp nextjs-app.tar.gz "s3://${DEPLOYMENT_BUCKET}/{{frontendModule.moduleId}}/{{{githubVarsOpen}}} github.sha {{{githubVarsClose}}}.tar.gz"
          echo "‚úÖ Uploaded to s3://${DEPLOYMENT_BUCKET}/{{frontendModule.moduleId}}/{{{githubVarsOpen}}} github.sha {{{githubVarsClose}}}.tar.gz"

      - name: Deploy to EC2 via SSM
        run: |
          echo "üöÄ Deploying to EC2 instances..."

          # Send deployment command to EC2 instances
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Application,Values={{projectName}}" "Key=tag:Environment,Values={{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}" \
            --parameters "commands=[
              'set -e',
              'APP_DIR=/opt/{{frontendModule.moduleId}}',
              'echo \"üì• Downloading deployment package...\"',
              'aws s3 cp s3://${DEPLOYMENT_BUCKET}/{{frontendModule.moduleId}}/{{{githubVarsOpen}}} github.sha {{{githubVarsClose}}}.tar.gz /tmp/nextjs-app.tar.gz',
              'echo \"üì¶ Extracting package...\"',
              'sudo rm -rf \$APP_DIR/.next \$APP_DIR/public',
              'sudo tar -xzf /tmp/nextjs-app.tar.gz -C \$APP_DIR',
              'echo \"üì¶ Installing production dependencies...\"',
              'cd \$APP_DIR && npm ci --production',
              'echo \"üîÑ Restarting application...\"',
              'pm2 restart {{frontendModule.moduleId}} || pm2 start .next/standalone/server.js --name {{frontendModule.moduleId}}',
              'echo \"‚úÖ Deployment complete!\"'
            ]" \
            --comment "Deploy Next.js SSR {{{githubVarsOpen}}} github.sha {{{githubVarsClose}}}" \
            --query "Command.CommandId" \
            --output text)

          echo "üìã SSM Command ID: $COMMAND_ID"

          # Wait for command to complete
          echo "‚è≥ Waiting for deployment to complete..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$(aws ec2 describe-instances \
              --filters "Name=tag:Application,Values={{projectName}}" "Name=tag:Environment,Values={{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}" "Name=instance-state-name,Values=running" \
              --query "Reservations[0].Instances[0].InstanceId" \
              --output text)" || true

          # Check command status
          STATUS=$(aws ssm list-commands --command-id "$COMMAND_ID" --query "Commands[0].Status" --output text)
          if [ "$STATUS" = "Success" ]; then
            echo "‚úÖ Deployment successful!"
          else
            echo "‚ùå Deployment failed with status: $STATUS"
            aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$(aws ec2 describe-instances \
                --filters "Name=tag:Application,Values={{projectName}}" "Name=tag:Environment,Values={{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}" "Name=instance-state-name,Values=running" \
                --query "Reservations[0].Instances[0].InstanceId" \
                --output text)" || true
            exit 1
          fi
{{/isSsrMode}}
